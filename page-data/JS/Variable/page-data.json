{"componentChunkName":"component---src-templates-post-template-tsx","path":"/JS/Variable/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<h3>1. var 키워드</h3>\n<ul>\n<li>\n<p><span style='background-color: #fff5b1;'><strong>중복 선언 가능.</strong></span></p>\n</li>\n<li>\n<p><strong>초기화문 유무</strong>에 따라 중복 선언은 다르게 동작한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> x <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\n<span class=\"token keyword\">var</span> y <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\n\n<span class=\"token keyword\">var</span> x <span class=\"token operator\">=</span> <span class=\"token number\">100</span>\n<span class=\"token comment\">//var 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언이 가능.</span>\n<span class=\"token comment\">//초기화문이 있는 변수 선언은 자바스크립트 엔진에 의해 var 키워드가 없는 것처럼 동작!</span>\n<span class=\"token keyword\">var</span> y\n<span class=\"token comment\">//초기화문이 없는 변수 선언은 무시</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span> <span class=\"token comment\">//100</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>y<span class=\"token punctuation\">)</span> <span class=\"token comment\">//1</span></code></pre></div>\n</li>\n<li>\n<p>함수 레벨 스코프</p>\n<ul>\n<li>var 키워드로 선언한 변수는 <span style='background-color: #fff5b1'><strong>함수의 코드 블록만</strong>을 지역 스코프로 인정한다.</span></li>\n<li>함수 외부에서 선언한 var 키워드 변수는 코드 블록 내에서 선언해도 모두 전연 변수가 된다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> i <span class=\"token operator\">=</span> <span class=\"token number\">10</span>\n\n<span class=\"token comment\">//for문에서 선언한 i는 전역 변수로, 이미 선언된 전역 변수 i가 있으므로 중복 선언된다.</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">var</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span> <span class=\"token comment\">//0 1 2 3 4</span>\n<span class=\"token punctuation\">}</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span> <span class=\"token comment\">//5 -> 의도치않게 변경됨</span></code></pre></div>\n<ul>\n<li>함수 레벨 스코프는 전역 변수를 남발할 가능성을 높이고, 의도치 않게 전역 변수가 중복 선언되는 경우가 발생한다.</li>\n</ul>\n</li>\n<li>\n<p><strong>변수 호이스팅.</strong></p>\n<ul>\n<li>var 키워드로 변수를 선언하면 변수 호이스팅에 의해 런타임 이전에 undefined로 만들어진다.</li>\n<li>변수 선언문 이전에 참조할 수 있으나, 언제나 undefined를 반환한다.\n<ul>\n<li><span style='background-color: #fff5b1'>암묵적으로 자바스크립트 엔진이 선언단계, 초기화 단계가 한번에 진행한다.</span></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3>2. let 키워드</h3>\n<ul>\n<li>\n<p><strong>ES6</strong>에서 등장.</p>\n</li>\n<li>\n<p><strong>중복 선언 불가능.</strong></p>\n<ul>\n<li>에러 발생.</li>\n</ul>\n<div style=\"width: 80%;\"><span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 549px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/4b77f37561c23f7e0e78037c20e79ad7/ffc28/SyntaxErrorLet.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 8.854166666666666%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAACCAYAAABYBvyLAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAUklEQVR42qXJQQqAIBQAUe9/xkp/akJq0CITKifCI/RgVqP2WEi5UsvDpzV+UfegubTwaAFjYAngHMgM1sIaIQTwHkR61vVnBNIGR+FMmWWceAF6WJqlSkvggwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <picture>\n          <source srcset=\"/static/4b77f37561c23f7e0e78037c20e79ad7/a59e9/SyntaxErrorLet.webp 192w,\n/static/4b77f37561c23f7e0e78037c20e79ad7/0ca9f/SyntaxErrorLet.webp 384w,\n/static/4b77f37561c23f7e0e78037c20e79ad7/a6384/SyntaxErrorLet.webp 549w\" sizes=\"(max-width: 549px) 100vw, 549px\" type=\"image/webp\">\n          <source srcset=\"/static/4b77f37561c23f7e0e78037c20e79ad7/3b721/SyntaxErrorLet.png 192w,\n/static/4b77f37561c23f7e0e78037c20e79ad7/66595/SyntaxErrorLet.png 384w,\n/static/4b77f37561c23f7e0e78037c20e79ad7/ffc28/SyntaxErrorLet.png 549w\" sizes=\"(max-width: 549px) 100vw, 549px\" type=\"image/png\">\n          <img class=\"gatsby-resp-image-image\" src=\"/static/4b77f37561c23f7e0e78037c20e79ad7/ffc28/SyntaxErrorLet.png\" alt=\"SyntaxErrorLet\" title=\"\" loading=\"lazy\" decoding=\"async\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\">\n        </picture>\n  </a>\n    </span></div>\n</li>\n<li>\n<p><strong>블록 레벨 스코프.</strong></p>\n<ul>\n<li><span style='background-color: #fff5b1'>모든 코드 블록(함수, if, for, while 등)을 지역 스코프로 인정한다.</span></li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">let</span> foo <span class=\"token operator\">=</span> <span class=\"token number\">1</span> <span class=\"token comment\">//전역 변수</span>\n\n<span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> foo <span class=\"token operator\">=</span> <span class=\"token number\">2</span> <span class=\"token comment\">//지역 변수</span>\n  <span class=\"token keyword\">let</span> bar <span class=\"token operator\">=</span> <span class=\"token number\">1</span> <span class=\"token comment\">//지역 변수</span>\n<span class=\"token punctuation\">}</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>foo<span class=\"token punctuation\">)</span> <span class=\"token comment\">//1</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>bar<span class=\"token punctuation\">)</span> <span class=\"token comment\">//Uncaught ReferenceError: bar is not defined</span></code></pre></div>\n</li>\n<li>\n<p><strong>변수 호이스팅.</strong></p>\n<ul>\n<li>var 키워드와 달리 변수 호이스팅이 발생하지 않는 것처럼 동작한다.</li>\n<li>let 키워드로 선언한 변수는 <code class=\"language-text\">선언 단계</code> 와 <code class=\"language-text\">초기화 단계</code>가 분리되어 진행된다.</li>\n<li><span style='background-color: #fff5b1; font-weight: 700'>런타임 이전에 자바스크립트 엔진에 의해 암묵적으로 선언단계는 진행되지만, 초기화 단계는 변수 선언문에 도달했을 때 실행된다.</span>\n<ul>\n<li>초기화 단계 전에 변수 접근 시 참조 에러(ReferenceError)가 발생한다.</li>\n</ul>\n</li>\n<li>스코프의 시작 지점부터 초기화 시작 지점까지 변수를 참조할 수 없는 구간을 <code class=\"language-text\">일시적 사각지대</code>(TDZ: Temporal Dead Zone)이라고 한다.</li>\n</ul>\n</li>\n</ul>\n<h3>3. const 키워드</h3>\n<ul>\n<li>\n<p><strong>ES6</strong>에서 등장.</p>\n</li>\n<li>\n<p><strong>let 키워드와 거의 동일</strong>하게 블록 레벨 스코프를 가지며, 변수 호이스팅이 발생하지 않는 것처럼 동작한다.</p>\n</li>\n<li>\n<p>const 키워드로 선언한 변수는 <span style='background-color: #fff5b1'><strong>반드시 선언과 동시에 초기화</strong></span>해야 한다.</p>\n</li>\n<li>\n<p><strong>재할당 금지.</strong></p>\n</li>\n<li>\n<p>재할당 금지의 특징을 이용해서 const 키워드는 <strong>상수를 표현</strong>하는데 사용하기도 한다.</p>\n<ul>\n<li>상수의 이름은 <strong>대문자</strong>로 선언한다.</li>\n<li>여러 단어로 이뤄진 경우, <strong>스네이크 케이스</strong>로 표현하는 것이 일반적이다.</li>\n</ul>\n</li>\n<li>\n<p>객체</p>\n<ul>\n<li>\n<p>const 키워드로 선언된 변수는 재할당이 불가하지만,<span style='background-color: #fff5b1'> <strong>객체를 할당한 경우 값을 변경할 수 있다.</strong> </span> <br/>👉🏻 원시값(변경 불가능한 값)은 재할당 없이 변경할 수 있는 방법이 없지만, 변경 가능한 객체는 재할당 없이도 직접 변경이 가능하기 때문이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> persone <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> <span class=\"token string\">'Jung'</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">//객체는 변경 가능할 값이다. 재할당 없이 변경이 가능하다!</span>\nperson<span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token string\">'Kim'</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>persone<span class=\"token punctuation\">)</span> <span class=\"token comment\">// {name: 'Kim'}</span></code></pre></div>\n<aside>\n💡 const 키워드는 재할당을 금지할 뿐 “불변”을 의미하지는 않는다.\n</aside>\n</li>\n</ul>\n</li>\n</ul>\n<h3>정리</h3>\n<ul>\n<li>변수 선언 시 기본적으로 const를 사용하고, 재할딩이 필요한 경우 let을 사용하는 것이 좋다.</li>\n<li>ES6를 사용한다면 var 키워드는 사용하지 않는다.</li>\n<li>재할당이 필요한 경우 한정해 let 키워드를 사용한다.</li>\n<li>변경이 발생하지 않고 읽기 전용으로 사용하는 원시 값과 객체에는 const 키워드를사용한다. <br/> ↳ const는 재할당을 금지하므로 var, let 키워드보다 안전하다.</li>\n</ul>\n<br/>","frontmatter":{"title":"변수 선언 3가지 키워드","date":"2023.09.19.","categories":["변수 선언","JS"]}}}]}},"pageContext":{"slug":"/JS/Variable/"}},"staticQueryHashes":[],"slicesMap":{}}